# üìÑ PR0204: Gesti√≥n de procesos en Linux

## ‚úÖ Objetivos
- Familiarizarse con los procesos en un sistema Linux, utilizando diversas herramientas y comandos para monitorizar, gestionar y manipular procesos.

## üìå 1. Exploraci√≥n b√°sica de procesos

### Apartado 1
Como solo me aparecen dos procesos, apunto solo dos en vez de tres, que son **1666** y **1764**. Para que sean 3 habr√≠a que ejecutar uno m√°s.

![Apartado 1](Imagenes/Ej1A1.png)

### Apartado 2
Ponemos `ps aux` y de toda la lista, pondr√© el PID de **syslog**  que es **816**.

![Apartado 2](Imagenes/Ej1A2.png)

### Apartado 3

#### ¬øQu√© diferencia hay entre el comando `ps` y `ps aux`?
El comando `ps` muestra solo los procesos de la terminal del usuario que se est√© usando en ese momento.  
Mientras que el comando `ps aux`, muestra todos los procesos en el sistema, incluyendo otros usuarios que no tienen una terminal asociada.

#### Cuando decimos que un proceso pertenece a un usuario, ¬øqu√© implicaciones tiene? Es decir, ¬øen qu√© afecta eso al proceso?
El usuario propietaro del proceso hace que ese usuario es el que ha ejecutado tal proceso.

Tambi√©n, tiene los permisos del propietario, es decir, un proceso con otro usuario no puede eliminar directorios del directorio ra√≠z por mucho que se intente ejecutar el proceso. Para ello, habr√≠a que usar el usuario `root`.

## üìå 2. Monitorizaci√≥n de procesos en tiempo real

### Apartado 1
El proceso que consume m√°s **CPU**, se encuentra en el primer lugar y cambia cada 5 segundos por defecto.

![Apartado 1](Imagenes/Ej2A1.png)

El PID, que es lo primero de la tabla, es **40**.

### Apartado 2
Cuando se haya ejecutado `top`, pulsamos la tecla **M** y se ordena tanto por el uso de la CPU como la memoria usada.

![Apartado 2](Imagenes/Ej2A2.png)

En este caso, el proceso que m√°s consume es el **http**.

### Apartado 3

#### ¬øQu√© columnas de informaci√≥n se muestran en `top` y cu√°l es su significado?
- **PID:** Identificador √∫nico del proceso.

- **USER:** Nombre del usuario que ejecuta el proceso.

- **PR:** Prioridad del proceso del kernel.

- **NI:** Valor `nice`, que determina la prioridad del proceso (un valor m√°s bajo significa mayor prioridad).

- **VIRT:** Memoria virtual total utilizada por el proceso.

- **RES:** Tama√±o de la memoria f√≠sica que est√° usando actualmente el proceso.

- **SHR:** Memoria compartida utilizada por el proceso.

- **S:** Estado del proceso.

- **%CPU:** Porcentaje de uso de la CPU que el proceso est√° consumiendo.

- **%MEM:** Porcentaje de memoria RAM f√≠sica total utilizada por el proceso.

- **TIME+:** Tiempo total acumulado que el proceso ha estado ejecut√°ndose.

- **COMMAND:** Nombre del comando que inici√≥ el proceso.

#### ¬øC√≥mo puedes cambiar el intervalo de actualizaci√≥n de `top`?
Para cambiar el intervalo de actualizaci√≥n de `top`, ponemos el comando y despu√©s pulsamos la tacla **D**. Saldr√° como un aviso con el texto **Change delay from** en el que muestra a cuantos segundos est√° y luego ponemos el n√∫mero que queramos pero en segundos y despu√©s pulsamos **Enter**.

![Apartado 3](Imagenes/Ej2A3.png)

## üìå 3. Detener y reanudar procesos

### Apartado 1
Ponemos `sleep 300 &` y crearemos un proceso que durar√° **300** segundos.

![Apartado 1](Imagenes/Ej3A1.png)

### Apartado 2
Si ponemos `jobs`, veremos todos los procesos en segundo plano, tambi√©n aparece el proceso que hemos creado en el apartado anterior. Para que muestre el **ID**, ponemos el modificador `-l`, es decir, `jobs -l`. el proceso es: **1693**.

![Apartado 2](Imagenes/ej3A2.png)

### Apartado 3
Para detener el proceso, ponemos `kill` y poniendo como modificador el n√∫mero de la se√±al **SIGSTOP** que es el **20**. En este caso, pondr√≠amos `kill -n 20 1963`.

### Apartado 4
Para reanudar el proceso, ponemos la se√±al **SIGCONT** que su n√∫mero es el **18** con `kill`. Quedar√≠a `kill -n 18 1963`.

### Apartado 5

#### ¬øQu√© efecto tiene la se√±al SIGSTOP sobre un proceso?
Provoca que un proceso se detenga o se pause temporalmente, al igual que en **Ctrl+Z**. A diferencia de otras se√±ales que un proceso puede ignorar o manejar de forma personalizada, `SIGSTOP` no se puede capturar, bloquear ni ignorar por el proceso. Esto significa que el sistema operativo la aplica de manera inmediata y forzosa. 

#### ¬øC√≥mo puedo verificar si un proceso est√° detenido o en ejecuci√≥n?
En los comandos tanto para `ps` como en `top`, hay una columna llamada **STATE** que es el estado del proceso y se representa con una letra que son las siguientes:
- **R:** *Running* (En ejecuci√≥n).

- **S:** *Sleeping* (Durmiendo, inactivo pero ejecutable).

- **T:** *Stopped* (Detenido). Puede ser temporal, como Ctrl+Z.

- **Z:** *Zombie* (Zombi, ha terminado pero sigue en la tabla).

## üìå 4. Terminar procesos

### Apartado 1
Ponemos `sleep 600 &` y creamos un proceso que dura **600** segundos.

![Apartado 1](Imagenes/Ej4A1.png)

### Apartado 2
Ponemos `ps` y como tenemos muy pocos procesos en ejecuci√≥n, podemos verlo f√°cilmente. El PID es **1191**.

![Apartado 2](Imagenes/Ej4A2.png)

Si tenemos muchos procesos en ejecuci√≥n, habr√° que poner un comando para que busque concretamente el proceso, el comando es `ps aux | egrep "sleep 600"`.

![Apartado 2_1](Imagenes/Ej4A2_1.png)

### Apartado 3
Para matar un proceso, se usa `kill` y la se√±al **SIGKILL** que su n√∫mero es el **9** m√°s el PID del proceso. El comando final ser√≠a `kill -9 1191`.

### Apartado 4

#### ¬øQu√© diferencia hay entre las se√±ales SIGTERM y SIGKILL?
Detiene temporalmente el proceso, como si hubi√©semos pulsado **Ctrl+Z** mientras ejecutamos un proceso. Deja el proceso preparado para poder continuarlo en cualquier momento con la se√±al **SIGCONT(18)**.

#### ¬øPor qu√© es preferible utilizar SIGTERM antes que SIGKILL para terminar un proceso?
Es mejor usar `SIGTERM` en vez de `SIGKILL` para terminar un proceso porque `SIGTERM` s√≠ que permite una terminaci√≥n controlada, mientras que `SIGKILL` realiza una terminaci√≥n forzada. 

## üìå 5. Prioridades de procesos

### Apartado 1
Ponemos `nice -n 10 sleep 300 &` para crear un proceso con prioridad baja.

![Apartado 1](Imagenes/Ej5A1.png)

### Apartado 2
Ponemos `ps -l` para ver la prioridad del proceso. Nos fijamos en el valor de **NI**, en este caso, es el **10** aunque est√© en el medio.

![Apartado 2](Imagenes/Ej5A2.png)

### Apartado 3
Para cambiar la prioridad del proceso, ponemos `renice` m√°s el valor que queramos, que en este caso es el **5** y luego el **PID** del proceso. Ser√≠a `sudo renice "valor" "PID"` porque sin sudo sale acceso denegado.

![](Imagenes/Ej5A3.png)

### Apartado 4

#### ¬øPara qu√© sirve el comando `nice`?
El comando `nice` se usa para crear un proceso con prioridad baja.

#### ¬øQu√© rango de valores puede tomar la prioridad (nice value) de un proceso y qu√© significa cada extremo?
Los valores de prioridad comienzan en **-20** (m√°xima prioridad) y terminan en **19** (m√≠nima prioridad).

#### ¬øQu√© ocurre si intentas cambiar la prioridad de un proceso que no te pertenece?
Dar√≠a error por falta de permisos. Si se quiere cambiar la prioridad, habr√≠a que hacerlo desde el usuario `root` o poniendo antes del comando `sudo`.

## üìå 6. Procesos en primer y segundo plano

### Apartado 1
Ponemos `sleep 200` y lo cancelamos con **Ctrl+Z**.

![Apartado 1](Imagenes/Ej6A1.png)

### Apartado 2
Ponemos `bg`, que significa *background*. Este comando mueve aquellos procesos que han sido detenidos a que se ejecuten en segundo plano. Al usarse, veremos que aparece el proceso que hemos cancelado en el ejercicio anterior.

![Apartado 2](Imagenes/Ej6A2.png)

### Apartado 3
Ponemos `fg`, que significa *foreground*. Este comando mueve todos aquellos procesos que est√°n en segundo plano a primer plano.

![Apartado 3](Imagenes/Ej6A3.png)

### Apartado 4

#### ¬øQu√© significa que un proceso est√° en segundo plano?
Significa que el proceso se sigue ejecutando sin la necesidad de que el usuario interfiera.

#### ¬øQu√© comando utilizar√≠as para mover un proceso detenido a segundo plano?
Antes tenemos que saber que se ha detenido con **Ctrl+Z**. Luego, lo movemos a segundo plano con `bg`.

#### ¬øC√≥mo puedes traer un proceso de segundo plano a primer plano si tienes m√∫ltiples trabajos en segundo plano?
El comando para mover los procesos de segundo a primer plano es `fg`, entonces, para mover un proceso concreto a primer plano, tenemos que poner el comando `jobs` para saber cu√°ntos procesos tenemos parados.

Podemos ver el identificador del proceso en primer lugar y tenerlo m√°s f√°cil a la hora de manipularse. Ahora, ponemos el comando `jobs` m√°s el modificador `%N`, donde **N** es el n√∫mero del proceso. Un ejemplo puede ser este:

![Apartado 4](Imagenes/Ej6A4.png)

## üìå 7. Uso de `pstree` y `htop`

### Apartado 1
Ponemos `htop`. Si vemos que no funciona el comando, podemos instalarlo con `sudo apt install htop`. En mi caso ya ven√≠a instalado.

### Apartado 2
Al poner `htop`, vemos una tabla en la que podemos interactuar con ella.

Al hacer clic en una columna (fila verde de arriba), se va a filtrar por ello, aparece el bloque en color azul y a la derecha una flecha. Por ejemplo:

![Apartado 2](Imagenes/Ej7A2.png)

### Apartado 3
Al poner `pstree`, podemos ver en forma de √°rbol y estructurado con ramificaciones de que los procesos dependen de otros procesos.

Por poner un ejemplo, el proceso **dbus**, es el proceso padre, mientras que **daemon**, es el proceso hijo. 

![Apartado 3](Imagenes/Ej7A3.png)

### Apartado 4

#### ¬øQu√© ventaja tiene utilizar `pstree` frente a `ps` para visualizar procesos?
La ventaja principal es que se puede ver de manera directa y visual los procesos que dependen de otros. As√≠, si se van a tocar procesos, podremos sabes cu√°les no deber√≠amos tocar para evitar que los procesos hijos se detengan.

#### ¬øC√≥mo puedes filtrar procesos por usuario en htop?
Con `htop`, al ser interactivo, clicamos en una columna de arriba, en este caso en **USER** y podemos ver los usuarios en primer lugar y ordenados alfab√©ticamente.

![Apartado 4](Imagenes/Ej7A2.png)

## üìå 8. Matar procesos de manera forzosa

### Apartado 1
Creamos un proceso que dure 400 segundos con `sleep 400 &`.

![Apartado 1](Imagenes/Ej8A1.png)

### Apartado 2
Para matar un proceso, usamos `kill -9`, tenemos que ver el **PID** del proceso para poder ponerlo al final del propio comando. Para ello, pondremos `ps aux | egrep sleep`.

Para comprobar que se haya eliminado, volvemos a poner `ps aux | egrep sleep` y aparecer√° el proceso como **Killed**.

![Apartado 2](Imagenes/Ej8A2.png)

### Apartado 3

#### ¬øEn qu√© casos ser√≠a necesario usar `kill -9` en lugar de `kill` sin opciones?
Se deber√≠a usar `kill -9` en lugar de `kill` sin modificadores cuando un proceso se ha quedado atascado, no responde y no puede terminarse de forma normal. El comando `kill` por defecto, env√≠a una se√±al a `SIGTERM` con el n√∫mero **15**, que hace si el proceso se puede terminar de manera segura.

#### ¬øQu√© riesgos implica usar SIGKILL para terminar un proceso?
Utilizar la se√±al `SIGKILL (9)` para terminar un proceso puede ser eficaz, pero fuerza la terminaci√≥n inmediata sin dar tiempo al proceso para que realice una salida limpia.

---
### [‚¨ÖÔ∏è Volver a UT02](../index.md)
---